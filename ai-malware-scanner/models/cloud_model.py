import os
import numpy as np
import joblib
from sklearn.preprocessing import StandardScaler
import requests
import tensorflow as tf
from tensorflow import keras
import smtplib
from email.mime.text import MIMEText

class ModelWrapper:
    _instance = None
    
    @classmethod
    def get_instance(cls, *args, **kwargs):
        """Singleton pattern to prevent multiple model loads"""
        if cls._instance is None:
            cls._instance = cls(*args, **kwargs)
        return cls._instance
    
    def __init__(self, model_path="models/classic_mlp.keras", model_type="keras"):
        """
        Initialize the model wrapper
        
        Args:
            model_path: Path to the model file
            model_type: Type of model (keras, svm, qsvm)
        """
        self.model_type = model_type
        # Ensure the models directory exists
        os.makedirs(os.path.dirname(model_path), exist_ok=True)
        
        # Available models in the repository
        self.available_models = {
            "classic_mlp": {"url": "https://github.com/fabiocaiulo8/malware-detection/raw/main/models/classic_mlp.keras", "type": "keras"},
            "hybrid_mlp": {"url": "https://github.com/fabiocaiulo8/malware-detection/raw/main/models/hybrid_mlp.h5", "type": "keras"},
            "bagging_svm": {"url": "https://github.com/fabiocaiulo8/malware-detection/raw/main/models/bagging_svm.pkl", "type": "svm"},
            "linear_svm": {"url": "https://github.com/fabiocaiulo8/malware-detection/raw/main/models/linear_svm.pkl", "type": "svm"},
            "bagging_qsvm": {"url": "https://github.com/fabiocaiulo8/malware-detection/raw/main/models/bagging_qsvm.pkl.xz", "type": "qsvm"},
            "linear_qsvm": {"url": "https://github.com/fabiocaiulo8/malware-detection/raw/main/models/linear_qsvm.pkl", "type": "qsvm"}
        }
        
        # Download model if it doesn't exist
        if not os.path.exists(model_path):
            print(f"Downloading pre-trained model from GitHub...")
            model_name = os.path.basename(model_path)
            model_key = model_name.split('.')[0]  # Get model name without extension
            
            if model_key in self.available_models:
                model_url = self.available_models[model_key]["url"]
                self.model_type = self.available_models[model_key]["type"]
                self._download_file(model_url, model_path)
            else:
                # Default to classic_mlp if model name not recognized
                print(f"Model {model_name} not recognized. Defaulting to classic_mlp.keras")
                model_url = self.available_models["classic_mlp"]["url"]
                self.model_type = "keras"
                self._download_file(model_url, model_path)
        
        # Create a default scaler since scaler.pkl isn't available in the repository
        self.scaler = StandardScaler()
        print("Using a default StandardScaler. For optimal results, the scaler should be fitted on training data.")
        
        # Load the model
        try:
            if self.model_type == "keras":
                self.model = keras.models.load_model(model_path)
                print(f"Keras model loaded from {model_path}")
                
                # Get input size from model
                self.input_size = self.model.input_shape[1]
                print(f"Model input size: {self.input_size}")
                
                # Verify model works by testing with dummy input
                self._test_model()
            elif self.model_type in ["svm", "qsvm"]:
                self.model = joblib.load(model_path)
                print(f"SVM model loaded from {model_path}")
                
                # Default input size for SVMs, should be updated based on specific model
                self.input_size = 16
                print(f"Using default input size for SVM: {self.input_size}")
        except Exception as e:
            print(f"Error loading model: {e}")
            self.input_size = 16
            self.model = None
            print("Model not available. Predictions will not work.")
    
    def _download_file(self, url, path):
        """Download a file from a URL to the specified path"""
        try:
            response = requests.get(url)
            if response.status_code == 200:
                with open(path, 'wb') as f:
                    f.write(response.content)
                print(f"File downloaded to {path}")
                return True
            else:
                print(f"Failed to download file: HTTP {response.status_code}")
                return False
        except Exception as e:
            print(f"Error downloading file: {e}")
            return False
    
    def _test_model(self):
        """Test the model with dummy input to ensure it works"""
        try:
            dummy_input = np.zeros((1, self.input_size), dtype=np.float32)
            result = self.model.predict(dummy_input)
            print("Model verification successful!")
        except Exception as e:
            print(f"Model verification failed: {e}")
            raise ValueError("Model compatibility check failed")
    
    def _send_alert(self, prediction):
        """
        Send an automated alert for high-risk predictions.
        
        Args:
            prediction: Dictionary containing prediction results.
        """
        try:
            if prediction.get("is_malicious") and prediction.get("confidence", 0) > 0.9:
                # Configure email settings
                sender_email = "alert@example.com"
                recipient_email = "admin@example.com"
                subject = "High-Risk Malware Detected"
                body = f"Malware detected with confidence {prediction['confidence']:.2f}.\nDetails: {prediction}"

                # Create email message
                msg = MIMEText(body)
                msg["Subject"] = subject
                msg["From"] = sender_email
                msg["To"] = recipient_email

                # Send email
                with smtplib.SMTP("smtp.example.com", 587) as server:
                    server.starttls()
                    server.login("alert@example.com", "password")
                    server.sendmail(sender_email, recipient_email, msg.as_string())
                print("Alert sent successfully.")
        except Exception as e:
            print(f"Failed to send alert: {e}")

    def predict(self, features):
        """
        Predict if a sample is malicious based on its features
        
        Args:
            features: List of numerical features
            
        Returns:
            Dictionary with prediction results
        """
        try:
            if self.model is None:
                return {"error": "Model not loaded properly. Cannot make predictions."}
            
            # Convert to numpy array if it's not already
            if not isinstance(features, np.ndarray):
                features = np.array(features, dtype=np.float32)
            
            # Reshape if it's a single sample
            if len(features.shape) == 1:
                features = features.reshape(1, -1)
                
            # Make sure we have the expected number of features
            if features.shape[1] != self.input_size:
                raise ValueError(f"Expected {self.input_size} features, got {features.shape[1]}")
            
            if self.model_type == "keras":
                # For keras models, we'll use our default scaler
                # Note: This scaling may not match the training data scaling
                scaled_features = self.scaler.fit_transform(features)
                
                # Get prediction
                probabilities = self.model.predict(scaled_features, verbose=0)
                
                # If the model outputs a single value (sigmoid), convert to two-class format
                if len(probabilities.shape) > 1 and probabilities.shape[1] == 1:
                    # Convert sigmoid output to two classes
                    malicious_prob = probabilities[0][0]
                    benign_prob = 1 - malicious_prob
                    probabilities = np.array([[benign_prob, malicious_prob]])
                
                predicted_class = np.argmax(probabilities, axis=1)[0]
                confidence = float(probabilities[0][predicted_class])
                
                result = {
                    "is_malicious": bool(predicted_class),
                    "confidence": confidence,
                    "label": "malicious" if predicted_class == 1 else "benign",
                    "raw_probabilities": [float(p) for p in probabilities[0]]
                }
                
                # Send alert if necessary
                self._send_alert(result)
                return result
            
            elif self.model_type in ["svm", "qsvm"]:
                # For SVM models, we'll skip scaling since most SVM implementations have built-in scaling
                try:
                    # Try to use predict_proba if available (for probability estimates)
                    probabilities = self.model.predict_proba(features)
                    predicted_class = np.argmax(probabilities, axis=1)[0]
                    confidence = float(probabilities[0][predicted_class])
                    
                    result = {
                        "is_malicious": bool(predicted_class),
                        "confidence": confidence,
                        "label": "malicious" if predicted_class == 1 else "benign",
                        "raw_probabilities": [float(p) for p in probabilities[0]]
                    }
                    
                    # Send alert if necessary
                    self._send_alert(result)
                    return result
                except:
                    # Fall back to binary prediction
                    prediction = self.model.predict(features)[0]
                    result = {
                        "is_malicious": bool(prediction),
                        "confidence": 1.0,  # No probability available
                        "label": "malicious" if prediction else "benign",
                        "raw_probabilities": [1.0 if prediction else 0.0, 0.0 if prediction else 1.0]
                    }
                    
                    # Send alert if necessary
                    self._send_alert(result)
                    return result
                
        except Exception as e:
            print(f"Error during prediction: {e}")
            return {"error": str(e)}
    
    def cloud_scan(self, features):
        """
        Placeholder for cloud-based scanning.
        
        Args:
            features: List of numerical features.
        
        Returns:
            Dictionary with prediction results.
        """
        print("Cloud-based scanning is not yet implemented.")
        return {"error": "Cloud-based scanning not implemented."}
