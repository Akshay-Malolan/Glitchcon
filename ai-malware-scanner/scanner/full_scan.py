import os
import sys
import time
import hashlib
import platform
import psutil
import logging
import argparse
import json
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from tqdm import tqdm
import traceback

# Add the parent directory to sys.path to ensure imports work correctly
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from static_analysis.analyze import extract_static_features, vectorize_features
from models.cloud_model import model
try:
    from dynamic_analysis.sandbox import run_dynamic_analysis
    DYNAMIC_ANALYSIS_AVAILABLE = True
except ImportError:
    DYNAMIC_ANALYSIS_AVAILABLE = False

# Set up log directory
log_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "logs")
os.makedirs(log_dir, exist_ok=True)

# Setup logging with proper file path
log_file = os.path.join(log_dir, "ai_malware_scanner.log")
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)
logger.info(f"Logging to file: {log_file}")

class MalwareScanner:
    def __init__(self, 
                use_dynamic_analysis=False, 
                max_workers=10, 
                max_file_size_mb=200,  # Increased from 100MB to 200MB
                deep_scan=False):
        self.use_dynamic_analysis = use_dynamic_analysis and DYNAMIC_ANALYSIS_AVAILABLE
        self.max_workers = max_workers
        self.max_file_size = max_file_size_mb * 1024 * 1024  # Convert to bytes
        self.deep_scan = deep_scan
        self.scan_results = {}
        self.stats = {
            "total_files": 0,
            "scanned_files": 0,
            "skipped_files": 0,
            "malicious_files": 0,
            "error_files": 0,
            "scan_start_time": None,
            "scan_end_time": None,
            "scan_duration": None
        }
    
    def scan_file(self, file_path):
        """Scan a single file for malware."""
        try:
            logger.info(f"Scanning file: {file_path}")
            
            # Check if file exists
            if not os.path.exists(file_path):
                logger.warning(f"File does not exist: {file_path}")
                return {
                    "file_path": file_path,
                    "status": "error",
                    "error": "File does not exist"
                }
                
            # Check if file is accessible
            if not os.access(file_path, os.R_OK):
                logger.warning(f"No permission to read file: {file_path}")
                return {
                    "file_path": file_path,
                    "status": "error",
                    "error": "No permission to read file"
                }
            
            # Skip files that are too large
            try:
                file_size = os.path.getsize(file_path)
                if file_size > self.max_file_size:
                    logger.info(f"Skipping file {file_path}: exceeds maximum size limit of {self.max_file_size/1024/1024}MB")
                    return {
                        "file_path": file_path,
                        "status": "skipped",
                        "reason": "file_size_exceeded",
                        "size_mb": file_size/1024/1024
                    }
            except Exception as e:
                logger.error(f"Error getting file size for {file_path}: {e}")
                return {
                    "file_path": file_path,
                    "status": "error",
                    "error": f"Error getting file size: {str(e)}"
                }
            
            # Extract static features
            try:
                features = extract_static_features(file_path)
                if not features:
                    logger.warning(f"Failed to extract features from {file_path}")
                    return {
                        "file_path": file_path,
                        "status": "error",
                        "error": "Failed to extract features"
                    }
            except Exception as e:
                logger.error(f"Error extracting features from {file_path}: {e}")
                logger.error(traceback.format_exc())
                return {
                    "file_path": file_path,
                    "status": "error",
                    "error": f"Feature extraction error: {str(e)}"
                }
            
            # Get basic file info for the result
            result = {
                "file_path": file_path,
                "file_name": os.path.basename(file_path),
                "file_size": features.get("file_size", 0),
                "file_type": features.get("file_type", "unknown"),
                "md5": features.get("md5", ""),
                "sha256": features.get("sha256", ""),
                "status": "scanned"
            }
            
            # Skip non-PE files if not in deep scan mode
            if not features.get("is_pe", False) and not self.deep_scan:
                result["status"] = "skipped"
                result["reason"] = "not_pe_file"
                return result
            
            # Vectorize features for model input
            feature_vector = None
            try:
                feature_vector = vectorize_features(features)
            except Exception as e:
                logger.error(f"Error vectorizing features for {file_path}: {e}")
                result["status"] = "error"
                result["error"] = f"Feature vectorization error: {str(e)}"
                return result
            
            if feature_vector:
                # Predict using the model
                try:
                    prediction = model.predict(feature_vector)
                    
                    # Add prediction to result
                    result.update({
                        "is_malicious": prediction.get("is_malicious", False),
                        "confidence": prediction.get("confidence", 0),
                        "prediction_label": prediction.get("label", "unknown")
                    })
                    
                    # Run dynamic analysis if configured and file is potentially malicious
                    if self.use_dynamic_analysis and prediction.get("is_malicious", False) and prediction.get("confidence", 0) > 0.7:
                        logger.info(f"Running dynamic analysis for suspicious file: {file_path}")
                        dynamic_result = run_dynamic_analysis(file_path)
                        result["dynamic_analysis"] = dynamic_result
                except Exception as e:
                    logger.error(f"Error during prediction for {file_path}: {e}")
                    result["status"] = "error"
                    result["error"] = f"Prediction error: {str(e)}"
            else:
                result["status"] = "skipped" if features.get("is_pe", False) else "error"
                result["reason"] = "Could not vectorize features"
            
            return result
        except Exception as e:
            logger.error(f"Unhandled error scanning file {file_path}: {e}")
            logger.error(traceback.format_exc())
            return {
                "file_path": file_path,
                "status": "error",
                "error": str(e)
            }

    def scan_directory(self, directory, recursive=True, file_extensions=None):
        """Scan a directory for malware."""
        if file_extensions is None:
            # Default extensions to scan
            file_extensions = ['.exe', '.dll', '.sys', '.scr', '.bat', '.cmd', '.vbs', '.ps1', '.js']
        
        file_extensions = [ext.lower() for ext in file_extensions]
        files_to_scan = []
        
        # Reset stats
        self.stats = {
            "total_files": 0,
            "scanned_files": 0,
            "skipped_files": 0,
            "malicious_files": 0,
            "error_files": 0,
            "scan_start_time": datetime.now(),
            "scan_end_time": None,
            "scan_duration": None
        }
        
        # Collect files to scan
        logger.info(f"Collecting files from {directory}")
        if recursive:
            for root, _, files in os.walk(directory):
                for file in files:
                    if any(file.lower().endswith(ext) for ext in file_extensions) or self.deep_scan:
                        file_path = os.path.join(root, file)
                        files_to_scan.append(file_path)
                        self.stats["total_files"] += 1
        else:
            for file in os.listdir(directory):
                if any(file.lower().endswith(ext) for ext in file_extensions) or self.deep_scan:
                    file_path = os.path.join(directory, file)
                    if os.path.isfile(file_path):
                        files_to_scan.append(file_path)
                        self.stats["total_files"] += 1
        
        logger.info(f"Found {self.stats['total_files']} files to scan")
        
        # Scan files with progress bar
        self.scan_results = {}
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_file = {executor.submit(self.scan_file, file): file for file in files_to_scan}
            
            with tqdm(total=len(files_to_scan), desc="Scanning files") as pbar:
                for future in as_completed(future_to_file):
                    file = future_to_file[future]
                    try:
                        result = future.result()
                        self.scan_results[file] = result
                        
                        # Update stats
                        if result["status"] == "scanned":
                            self.stats["scanned_files"] += 1
                            if result.get("is_malicious", False):
                                self.stats["malicious_files"] += 1
                                logger.warning(f"Malicious file detected: {file} (Confidence: {result.get('confidence', 0):.2f})")
                        elif result["status"] == "skipped":
                            self.stats["skipped_files"] += 1
                        elif result["status"] == "error":
                            self.stats["error_files"] += 1
                        
                        pbar.update(1)
                    except Exception as e:
                        logger.error(f"Error processing scan result for {file}: {e}")
        
        # Update final stats
        self.stats["scan_end_time"] = datetime.now()
        self.stats["scan_duration"] = (self.stats["scan_end_time"] - self.stats["scan_start_time"]).total_seconds()
        
        # Print summary
        logger.info(f"\nScan Summary:")
        logger.info(f"Total files found: {self.stats['total_files']}")
        logger.info(f"Files scanned: {self.stats['scanned_files']}")
        logger.info(f"Files skipped: {self.stats['skipped_files']}")
        logger.info(f"Malicious files: {self.stats['malicious_files']}")
        logger.info(f"Error files: {self.stats['error_files']}")
        logger.info(f"Total scan time: {self.stats['scan_duration']:.2f} seconds")
        
        return {
            "stats": self.stats,
            "results": self.scan_results
        }

    def scan_system(self, exclude_dirs=None):
        """Scan the entire system for malware."""
        if exclude_dirs is None:
            exclude_dirs = []
        
        # Convert exclude_dirs to absolute paths
        exclude_dirs = [os.path.abspath(dir_path) for dir_path in exclude_dirs]
        
        # Get all drives
        drives = self._get_all_drives()
        logger.info(f"Detected {len(drives)} drives: {', '.join(drives)}")
        
        all_results = {}
        for drive in drives:
            logger.info(f"\nScanning {drive}...")
            drive_results = self.scan_directory(drive)
            all_results.update(drive_results.get("results", {}))
        
        return all_results

    def _get_all_drives(self):
        """Get all available drives/mount points in the system."""
        drives = []
        
        if platform.system() == "Windows":
            # For Windows, use drive letters
            for drive_letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
                drive_path = f"{drive_letter}:\\"
                if os.path.exists(drive_path):
                    drives.append(drive_path)
        else:
            # For Linux/Mac, use psutil to get mount points
            try:
                partitions = psutil.disk_partitions(all=False)
                for partition in partitions:
                    if os.path.exists(partition.mountpoint):
                        drives.append(partition.mountpoint)
            except:
                # Fallback for Linux if psutil fails
                if os.path.exists("/"):
                    drives.append("/")
        
        return drives

    def save_results(self, output_file):
        """Save scan results to a JSON file."""
        try:
            # Create output directory if it doesn't exist
            output_dir = os.path.dirname(output_file)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)
            
            # Prepare results with timestamps converted to strings
            serializable_stats = self.stats.copy()
            if serializable_stats.get("scan_start_time"):
                serializable_stats["scan_start_time"] = serializable_stats["scan_start_time"].isoformat()
            if serializable_stats.get("scan_end_time"):
                serializable_stats["scan_end_time"] = serializable_stats["scan_end_time"].isoformat()
            
            results_to_save = {
                "stats": serializable_stats,
                "results": self.scan_results
            }
            
            with open(output_file, 'w') as f:
                json.dump(results_to_save, f, indent=4)
                
            logger.info(f"Results saved to {output_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving results to {output_file}: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(description="AI Malware Scanner")
    
    # Main scan targets
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-f", "--file", help="Path to file to scan")
    group.add_argument("-d", "--directory", help="Path to directory to scan")
    group.add_argument("--full-system", action="store_true", help="Perform a full system scan")
    
    # Scan options
    parser.add_argument("-r", "--recursive", action="store_true", help="Scan directory recursively")
    parser.add_argument("--deep", action="store_true", help="Perform deep scan (includes all file types)")
    parser.add_argument("--dynamic", action="store_true", help="Use dynamic analysis for suspicious files")
    parser.add_argument("--threads", type=int, default=10, help="Number of parallel scanning threads")
    
    # Output options
    parser.add_argument("-o", "--output", help="Output file for scan results (JSON format)")
    
    args = parser.parse_args()
    
    # Initialize scanner
    scanner = MalwareScanner(
        use_dynamic_analysis=args.dynamic,
        max_workers=args.threads,
        deep_scan=args.deep
    )
    
    # Perform scan based on arguments
    if args.file:
        logger.info(f"Scanning file: {args.file}")
        result = scanner.scan_file(args.file)
        scanner.scan_results = {args.file: result}
        
        if result.get("is_malicious", False):
            logger.warning(f"Malicious file detected: {args.file}")
            logger.warning(f"Confidence: {result.get('confidence', 0):.2f}")
        else:
            logger.info(f"No malware detected in file: {args.file}")
            
    elif args.directory:
        logger.info(f"Scanning directory: {args.directory}")
        scanner.scan_directory(args.directory, recursive=args.recursive)
        
    elif args.full_system:
        logger.info("Starting full system scan...")
        exclude_dirs = [
            os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", ".git"),
            os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "venv")
        ]
        scanner.scan_system(exclude_dirs=exclude_dirs)
    
    # Save results if output file specified
    if args.output:
        scanner.save_results(args.output)
    
    # Print summary to console
    malicious_count = sum(1 for r in scanner.scan_results.values() if r.get("is_malicious", False))
    logger.info(f"Scan complete. Found {malicious_count} malicious files.")
    
    # Return malicious file count as exit code
    return malicious_count

if __name__ == "__main__":
    sys.exit(main())
