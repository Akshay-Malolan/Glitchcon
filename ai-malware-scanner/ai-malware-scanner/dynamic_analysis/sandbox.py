import os
import time
import json
import logging
import tempfile
import subprocess
import platform
import psutil
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ProcessMonitor:
    """
    Basic process activity monitor for lightweight dynamic analysis.
    This is a simplified alternative to a full sandbox environment.
    """
    def __init__(self, duration=30):
        """
        Initialize the process monitor
        
        Args:
            duration: How long to monitor the process in seconds
        """
        self.duration = duration
        
    def _collect_process_info(self, proc):
        """Collect key information about a running process"""
        try:
            info = {
                "pid": proc.pid,
                "name": proc.name(),
                "status": proc.status(),
                "created_time": datetime.fromtimestamp(proc.create_time()).isoformat(),
                "cpu_percent": proc.cpu_percent(),
                "memory_percent": proc.memory_percent(),
                "threads": len(proc.threads()),
                "open_files": [],
                "connections": []
            }
            
            # Get open files
            try:
                info["open_files"] = [f.path for f in proc.open_files()]
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
                
            # Get network connections
            try:
                connections = []
                for conn in proc.connections():
                    if conn.laddr and len(conn.laddr) >= 2:
                        connections.append({
                            "local_addr": f"{conn.laddr[0]}:{conn.laddr[1]}",
                            "remote_addr": f"{conn.raddr[0]}:{conn.raddr[1]}" if conn.raddr else None,
                            "status": conn.status
                        })
                info["connections"] = connections
            except (psutil.AccessDenied, psutil.NoSuchProcess):
                pass
            
            return info
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            return None
            
    def monitor_executable(self, file_path):
        """
        Execute and monitor a file for suspicious activity
        
        Args:
            file_path: Path to the executable to run and monitor
            
        Returns:
            Dictionary with monitoring results
        """
        if not os.path.isfile(file_path):
            return {"error": f"File not found: {file_path}"}
            
        if not os.access(file_path, os.X_OK) and platform.system() != "Windows":
            return {"error": f"File is not executable: {file_path}"}
            
        logger.info(f"Starting to monitor: {file_path}")
        
        # Create a temporary directory for any artifacts
        temp_dir = tempfile.mkdtemp(prefix="monitor_")
        
        try:
            # Start the process
            start_time = time.time()
            if platform.system() == "Windows":
                # Use start /B on Windows to avoid opening a new window
                process = subprocess.Popen(
                    file_path,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    creationflags=subprocess.CREATE_NO_WINDOW
                )
            else:
                process = subprocess.Popen(
                    [file_path],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
            
            logger.info(f"Process started with PID: {process.pid}")
            
            # Collect process information over time
            snapshots = []
            children = []
            network_activity = set()
            file_activity = set()
            end_time = start_time + self.duration
            
            while time.time() < end_time and process.poll() is None:
                # Get the main process
                try:
                    proc = psutil.Process(process.pid)
                    proc_info = self._collect_process_info(proc)
                    if proc_info:
                        snapshots.append(proc_info)
                        
                        # Track network activity
                        for conn in proc_info.get("connections", []):
                            if conn.get("remote_addr"):
                                network_activity.add(conn["remote_addr"])
                        
                        # Track file activity
                        for file_path in proc_info.get("open_files", []):
                            file_activity.add(file_path)
                except:
                    logger.warning(f"Failed to get info for process {process.pid}")
                
                # Get child processes
                try:
                    for child in psutil.Process(process.pid).children(recursive=True):
                        child_info = self._collect_process_info(child)
                        if child_info and child_info["pid"] not in [c["pid"] for c in children]:
                            children.append(child_info)
                except:
                    pass
                
                time.sleep(1)
            
            # Try to terminate the process if it's still running
            if process.poll() is None:
                logger.info(f"Terminating process {process.pid}")
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
            
            stdout, stderr = process.communicate()
            
            # Collect results
            results = {
                "status": "completed",
                "executable": file_path,
                "monitoring_duration": time.time() - start_time,
                "process_snapshots": snapshots,
                "child_processes": children,
                "network_connections": list(network_activity),
                "file_activity": list(file_activity),
                "stdout": stdout.decode(errors='replace'),
                "stderr": stderr.decode(errors='replace'),
                "exit_code": process.returncode,
                "artifacts_dir": temp_dir
            }
            
            # Save results to a file in the temp directory
            result_file = os.path.join(temp_dir, "monitoring_results.json")
            with open(result_file, 'w') as f:
                # Some complex objects might not be JSON serializable, so we need to handle them carefully
                json_data = {}
                for key, value in results.items():
                    if key not in ["process_snapshots", "child_processes"]:
                        json_data[key] = value
                json.dump(json_data, f, indent=2)
            
            results["result_file"] = result_file
            
            # Analyze behavior
            suspicious_indicators = self._analyze_behavior(results)
            results["suspicious_indicators"] = suspicious_indicators
            results["risk_level"] = self._calculate_risk_level(suspicious_indicators)
            
            return results
            
        except Exception as e:
            logger.error(f"Error monitoring file {file_path}: {e}")
            return {"error": str(e), "artifacts_dir": temp_dir}
    
    def _analyze_behavior(self, results):
        """Analyze the monitoring results for suspicious behavior"""
        indicators = []
        
        # Check for network connections to suspicious ports
        suspicious_ports = [4444, 8080, 1080, 31337]  # Example suspicious ports
        for conn in results.get("network_connections", []):
            if not conn:
                continue
            try:
                addr_parts = conn.split(":")
                if len(addr_parts) >= 2:
                    port = int(addr_parts[1])
                    if port in suspicious_ports:
                        indicators.append(f"Connection to suspicious port: {port}")
            except:
                pass
        
        # Check for access to sensitive directories
        sensitive_dirs = ["/etc", "/var", "C:\\Windows\\System32", "C:\\Program Files"]
        for file_path in results.get("file_activity", []):
            if any(sensitive_dir in file_path for sensitive_dir in sensitive_dirs):
                indicators.append(f"Access to sensitive directory: {file_path}")
        
        # Check for too many child processes
        if len(results.get("child_processes", [])) > 5:
            indicators.append(f"Spawned many child processes: {len(results.get('child_processes', []))}")
        
        # Check for crash indicators in stderr
        error_indicators = ["segmentation fault", "access violation", "illegal operation"]
        for indicator in error_indicators:
            if indicator in results.get("stderr", "").lower():
                indicators.append(f"Process crashed with error: {indicator}")
        
        return indicators
    
    def _calculate_risk_level(self, indicators):
        """Calculate a risk level based on number of suspicious indicators"""
        if len(indicators) >= 3:
            return "High"
        elif len(indicators) >= 1:
            return "Medium"
        return "Low"

def run_dynamic_analysis(file_path, duration=30):
    """
    Run basic dynamic analysis on a file
    
    Args:
        file_path: Path to the file to analyze
        duration: Duration in seconds to monitor the file
        
    Returns:
        Dictionary with analysis results
    """
    monitor = ProcessMonitor(duration=duration)
    return monitor.monitor_executable(file_path)

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python sandbox.py <file_path> [duration]")
        sys.exit(1)
    
    file_to_analyze = sys.argv[1]
    duration = int(sys.argv[2]) if len(sys.argv) > 2 else 30
    
    result = run_dynamic_analysis(file_to_analyze, duration)
    
    if "error" in result:
        print(f"Error: {result['error']}")
        sys.exit(1)
    
    print(f"Analysis complete with risk level: {result.get('risk_level', 'Unknown')}")
    if result.get("suspicious_indicators"):
        print("\nSuspicious indicators found:")
        for indicator in result["suspicious_indicators"]:
            print(f"- {indicator}")
    
    print(f"\nDetailed results saved to: {result.get('result_file', 'unknown')}")
